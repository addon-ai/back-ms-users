{{#isJpaRepository}}
package {{packageName}};

import {{infra_entity}}.{{entityName}}Dbo;
import org.springframework.data.domain.Pageable;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.r2dbc.repository.R2dbcRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

/**
 * Spring Data R2DBC Repository for {{entityName}} entities.
 * <p>
 * This interface extends R2dbcRepository to provide reactive CRUD operations
 * and includes custom query methods for specific business requirements.
 * It operates on {{entityName}}Dbo entities for reactive database persistence.
 * </p>
 * 
 * @author {{author}}
 * @version {{version}}
 */
@Repository
public interface {{classname}} extends R2dbcRepository<{{entityName}}Dbo, UUID> {
    
    /**
     * Find entities with search functionality.
     */
    @Query("SELECT * FROM {{tableName}} u WHERE " +
           "(:search IS NULL OR :search = '' OR " +
           "LOWER(u.username) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
           "LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
           "LOWER(u.first_name) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
           "LOWER(u.last_name) LIKE LOWER(CONCAT('%', :search, '%'))) " +
           "ORDER BY u.created_at DESC " +
           "LIMIT :limit OFFSET :offset")
    Flux<{{entityName}}Dbo> findBySearchTerm(@Param("search") String search, 
                                             @Param("limit") Long limit, 
                                             @Param("offset") Long offset);
    
    /**
     * Count entities matching search term.
     */
    @Query("SELECT COUNT(*) FROM {{tableName}} u WHERE " +
           "(:search IS NULL OR :search = '' OR " +
           "LOWER(u.username) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
           "LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
           "LOWER(u.first_name) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
           "LOWER(u.last_name) LIKE LOWER(CONCAT('%', :search, '%')))")
    Mono<Long> countBySearchTerm(@Param("search") String search);
    
    /**
     * Find all entities with pagination.
     */
    @Query("SELECT * FROM {{tableName}} u ORDER BY u.created_at DESC LIMIT :limit OFFSET :offset")
    Flux<{{entityName}}Dbo> findAllPaged(@Param("limit") Long limit, @Param("offset") Long offset);
    
    /**
     * Count all entities.
     */
    @Query("SELECT COUNT(*) FROM {{tableName}}")
    Mono<Long> countAll();
}
{{/isJpaRepository}}

{{#isAdapter}}
package {{packageName}};

import {{domain_ports_output}}.{{portName}};
import {{domain_model}}.{{entityName}};
import {{infra_entity}}.{{entityName}}Dbo;
import {{infra_repository}}.{{jpaRepositoryName}};
import {{application_mapper}}.{{entityName}}Mapper;
import {{infra_config_exceptions}}.InternalServerErrorException;
import {{utils_package}}.LoggingUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

/**
 * Reactive repository adapter implementing the {{entityName}} domain port.
 * <p>
 * This adapter serves as the output adapter in Clean Architecture,
 * implementing the domain repository interface and delegating to
 * Spring Data R2DBC repository. It handles the conversion between
 * domain objects and database entities using MapStruct in a reactive manner.
 * </p>
 * 
 * @author {{author}}
 * @version {{version}}
 */
@Component
@RequiredArgsConstructor
public class {{classname}} implements {{portName}} {

    private static final LoggingUtils logger = LoggingUtils.getLogger({{classname}}.class);
    
    private final {{jpaRepositoryName}} r2dbcRepository;
    private final {{entityName}}Mapper mapper;

    @Override
    public Mono<{{entityName}}> save({{entityName}} {{entityVarName}}) {
        logger.debug("Saving {{entityName}}: {}", {{entityVarName}});
        return Mono.fromCallable(() -> mapper.toDbo({{entityVarName}}))
                .flatMap(r2dbcRepository::save)
                .map(mapper::toDomain)
                .doOnError(e -> logger.error("Database error while saving {{entityName}}", e, {{entityVarName}}))
                .onErrorMap(this::mapRepositoryException);
    }

    private Throwable mapRepositoryException(Throwable ex) {
        // Business logic exceptions - propagate to service layer
        if (ex instanceof org.springframework.dao.DuplicateKeyException) {
            logger.debug("Duplicate key constraint violation: {}", ex.getMessage());
            return ex;
        }
        if (ex instanceof org.springframework.dao.DataIntegrityViolationException) {
            logger.debug("Data integrity violation: {}", ex.getMessage());
            return ex;
        }
        // Technical exceptions - convert to infrastructure errors
        logger.error("Technical database error", ex);
        return new InternalServerErrorException("Failed to save {{entityName}}", ex);
    }

    @Override
    public Mono<{{entityName}}> findById(String id) {
        logger.debug("Finding {{entityName}} by id: {}", id);
        return r2dbcRepository.findById(UUID.fromString(id))
                .map(mapper::toDomain)
                .doOnError(e -> logger.error("Database error while finding {{entityName}} by id", e, id))
                .onErrorMap(e -> new InternalServerErrorException("Failed to find {{entityName}} by id", e));
    }

    @Override
    public Flux<{{entityName}}> findAll() {
        logger.debug("Finding all {{entityNamePlural}}");
        return r2dbcRepository.findAll()
                .map(mapper::toDomain)
                .doOnError(e -> logger.error("Database error while finding all {{entityNamePlural}}", e))
                .onErrorMap(e -> new InternalServerErrorException("Failed to find all {{entityNamePlural}}", e));
    }

    @Override
    public Mono<Void> deleteById(String id) {
        logger.debug("Deleting {{entityName}} by id: {}", id);
        return r2dbcRepository.deleteById(UUID.fromString(id))
                .doOnError(e -> logger.error("Database error while deleting {{entityName}} by id", e, id))
                .onErrorMap(e -> new InternalServerErrorException("Failed to delete {{entityName}} by id", e));
    }

    @Override
    public Mono<Boolean> existsById(String id) {
        logger.debug("Checking if {{entityName}} exists by id: {}", id);
        return r2dbcRepository.existsById(UUID.fromString(id))
                .doOnError(e -> logger.error("Database error while checking if {{entityName}} exists by id", e, id))
                .onErrorMap(e -> new InternalServerErrorException("Failed to check if {{entityName}} exists by id", e));
    }

    @Override
    public Flux<{{entityName}}> findBySearchTerm(String search, Integer page, Integer size) {
        logger.debug("Searching {{entityNamePlural}} with term: {}, page: {}, size: {}", search, page, size);
        
        long limit = size != null && size > 0 ? size : 20L;
        long offset = page != null && page > 0 ? (page - 1) * limit : 0L;
        
        return r2dbcRepository.findBySearchTerm(search, limit, offset)
                .map(mapper::toDomain)
                .doOnError(e -> logger.error("Database error while searching {{entityNamePlural}}", e, search))
                .onErrorMap(this::mapRepositoryException);
    }
    
    // Additional business methods for reactive operations
    public Mono<Long> countBySearchTerm(String search) {
        logger.debug("Counting {{entityNamePlural}} with search term: {}", search);
        return r2dbcRepository.countBySearchTerm(search)
                .doOnError(e -> logger.error("Database error while counting {{entityNamePlural}}", e, search))
                .onErrorMap(e -> new InternalServerErrorException("Failed to count {{entityNamePlural}}", e));
    }
    
    @Override
    public Flux<{{entityName}}> findAllPaged(Integer page, Integer size) {
        logger.debug("Finding all {{entityNamePlural}} with pagination: page={}, size={}", page, size);
        
        long limit = size != null && size > 0 ? size : 20L;
        long offset = page != null && page > 0 ? (page - 1) * limit : 0L;
        
        return r2dbcRepository.findAllPaged(limit, offset)
                .map(mapper::toDomain)
                .doOnError(e -> logger.error("Database error while finding all {{entityNamePlural}} paged", e))
                .onErrorMap(this::mapRepositoryException);
    }
    
    public Mono<Long> countAll() {
        logger.debug("Counting all {{entityNamePlural}}");
        return r2dbcRepository.countAll()
                .doOnError(e -> logger.error("Database error while counting all {{entityNamePlural}}", e))
                .onErrorMap(e -> new InternalServerErrorException("Failed to count all {{entityNamePlural}}", e));
    }
{{#hasComplexMethods}}
    
{{#repositoryMethods}}
    @Override
    public Flux<{{entityName}}> {{methodName}}({{parameters}}) {
        logger.debug("Executing {{methodName}} with parameters: {}", {{parameterName}});
        // TODO: Implement custom query for {{methodName}}
        return r2dbcRepository.findAll()
                .map(mapper::toDomain)
                .doOnError(e -> logger.error("Database error in {{methodName}}", e))
                .onErrorMap(e -> new InternalServerErrorException("Failed to execute {{methodName}}", e));
    }
    
{{/repositoryMethods}}
{{/hasComplexMethods}}
}
{{/isAdapter}}
