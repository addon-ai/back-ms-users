package {{packageName}};

import {{domain_ports_input}}.{{entityName}}UseCase;
import {{domain_ports_output}}.{{entityName}}RepositoryPort;
{{#hasCreate}}import {{application_dto}}.{{serviceName}}.Create{{entityName}}RequestContent;{{/hasCreate}}
{{#hasCreate}}import {{application_dto}}.{{serviceName}}.Create{{entityName}}ResponseContent;{{/hasCreate}}
{{#hasGet}}import {{application_dto}}.{{serviceName}}.Get{{entityName}}ResponseContent;{{/hasGet}}
{{#hasUpdate}}import {{application_dto}}.{{serviceName}}.Update{{entityName}}RequestContent;{{/hasUpdate}}
{{#hasUpdate}}import {{application_dto}}.{{serviceName}}.Update{{entityName}}ResponseContent;{{/hasUpdate}}
{{#hasDelete}}import {{application_dto}}.{{serviceName}}.Delete{{entityName}}ResponseContent;{{/hasDelete}}
{{#hasList}}import {{application_dto}}.{{serviceName}}.List{{entityName}}sResponseContent;{{/hasList}}
{{#hasComplexOperations}}
{{#complexOperations}}
import {{application_dto}}.{{serviceName}}.{{responseType}};
{{/complexOperations}}
{{/hasComplexOperations}}
import {{domain_model}}.{{entityName}};
import {{application_mapper}}.{{entityName}}Mapper;
import {{infra_config_exceptions}}.NotFoundException;
import {{utils}}.LoggingUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
{{#hasList}}
import java.util.List;
{{/hasList}}

/**
 * Consolidated application service implementing all {{entityName}} use cases.
 * 
 * @author {{author}}
 * @version {{version}}
 */
@Service
@RequiredArgsConstructor
@Transactional
public class {{entityName}}Service implements {{entityName}}UseCase {

    private static final LoggingUtils logger = LoggingUtils.getLogger({{entityName}}Service.class);
    
    private final {{entityName}}RepositoryPort {{entityVarName}}RepositoryPort;
    private final {{entityName}}Mapper {{entityVarName}}Mapper;

{{#hasCreate}}
    @Override
    public Create{{entityName}}ResponseContent create(Create{{entityName}}RequestContent request) {
        logger.info("Executing Create{{entityName}} with request: {}", request);
        
        try {
            {{entityName}} {{entityVarName}} = {{entityVarName}}Mapper.fromCreateRequest(request);
            {{entityName}} saved{{entityName}} = {{entityVarName}}RepositoryPort.save({{entityVarName}});
            logger.info("{{entityName}} created successfully with ID: {}", saved{{entityName}}.get{{entityName}}Id());
            return {{entityVarName}}Mapper.toCreateResponse(saved{{entityName}});
        } catch (Exception e) {
            logger.error("Error in Create{{entityName}}", e, request);
            throw e;
        }
    }
{{/hasCreate}}

{{#hasGet}}
    @Override
    public Get{{entityName}}ResponseContent get(String {{entityVarName}}Id) {
        logger.info("Executing Get{{entityName}} with {{entityVarName}}Id: {}", {{entityVarName}}Id);
        
        try {
            {{entityName}} {{entityVarName}} = {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            logger.info("{{entityName}} retrieved successfully with ID: {}", {{entityVarName}}Id);
            return {{entityVarName}}Mapper.toGetResponse({{entityVarName}});
        } catch (NotFoundException e) {
            logger.error("{{entityName}} not found in Get{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        } catch (Exception e) {
            logger.error("Error in Get{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        }
    }
{{/hasGet}}

{{#hasUpdate}}
    @Override
    public Update{{entityName}}ResponseContent update(String {{entityVarName}}Id, Update{{entityName}}RequestContent request) {
        logger.info("Executing Update{{entityName}} with {{entityVarName}}Id: {} and request: {}", {{entityVarName}}Id, request);
        
        try {
            {{entityName}} existing{{entityName}} = {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            // Merge request data into existing entity
            {{entityVarName}}Mapper.updateEntityFromRequest(request, existing{{entityName}});
            existing{{entityName}}.setUpdatedAt(java.time.Instant.now().toString());
            
            {{entityName}} saved{{entityName}} = {{entityVarName}}RepositoryPort.save(existing{{entityName}});
            logger.info("{{entityName}} updated successfully with ID: {}", {{entityVarName}}Id);
            
            return {{entityVarName}}Mapper.toUpdateResponse(saved{{entityName}});
        } catch (NotFoundException e) {
            logger.error("{{entityName}} not found in Update{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        } catch (Exception e) {
            logger.error("Error in Update{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        }
    }
{{/hasUpdate}}

{{#hasDelete}}
    @Override
    public Delete{{entityName}}ResponseContent delete(String {{entityVarName}}Id) {
        logger.info("Executing Delete{{entityName}} with {{entityVarName}}Id: {}", {{entityVarName}}Id);
        
        try {
            {{entityName}} {{entityVarName}} = {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            // Soft delete: update status to INACTIVE and set updatedAt
            {{entityVarName}}.setStatus("INACTIVE");
            {{entityVarName}}.setUpdatedAt(java.time.Instant.now().toString());
            {{entityVarName}}RepositoryPort.save({{entityVarName}});
            
            logger.info("{{entityName}} soft deleted (status set to INACTIVE) with ID: {}", {{entityVarName}}Id);
            
            return Delete{{entityName}}ResponseContent.builder()
                .deleted(true)
                .message("{{entityName}} deleted successfully")
                .build();
        } catch (NotFoundException e) {
            logger.error("{{entityName}} not found in Delete{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        } catch (Exception e) {
            logger.error("Error in Delete{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        }
    }
{{/hasDelete}}

{{#hasList}}
    @Override
    public List{{entityName}}sResponseContent list(Integer page, Integer size, String search, String status, String dateFrom, String dateTo) {
        logger.info("Executing List{{entityName}}s with page: {}, size: {}, search: {}, status: {}, dateFrom: {}, dateTo: {}", 
                   page, size, search, status, dateFrom, dateTo);
        
        try {
            // Apply default values
            String effectiveStatus = (status == null || status.trim().isEmpty()) ? "ACTIVE" : status;
            String effectiveDateFrom = dateFrom;
            String effectiveDateTo = dateTo;
            
            if (effectiveDateFrom == null || effectiveDateFrom.trim().isEmpty()) {
                effectiveDateFrom = java.time.Instant.now().minus(30, java.time.temporal.ChronoUnit.DAYS).toString();
            }
            if (effectiveDateTo == null || effectiveDateTo.trim().isEmpty()) {
                effectiveDateTo = java.time.Instant.now().toString();
            }
            
            logger.info("Effective filters - status: {}, dateFrom: {}, dateTo: {}", 
                       effectiveStatus, effectiveDateFrom, effectiveDateTo);
            
            List<{{entityName}}> {{entityVarName}}s = {{entityVarName}}RepositoryPort.findByFilters(
                search, effectiveStatus, effectiveDateFrom, effectiveDateTo, page, size);
            
            logger.info("Retrieved {} {{entityVarName}}s successfully", {{entityVarName}}s.size());
            return {{entityVarName}}Mapper.toListResponse({{entityVarName}}s, page != null ? page : 1, size != null ? size : 20);
        } catch (Exception e) {
            logger.error("Error in List{{entityName}}s", e);
            throw e;
        }
    }
{{/hasList}}

{{#hasComplexOperations}}
{{#complexOperations}}
    @Override
    public {{responseType}} {{methodName}}({{#hasPathVariables}}{{#pathVariables}}String {{name}}{{#hasMore}}, {{/hasMore}}{{/pathVariables}}{{/hasPathVariables}}) {
        logger.info("Executing {{operationId}}{{#hasPathVariables}} with {{#pathVariables}}{{name}}: {}{{#hasMore}}, {{/hasMore}}{{/pathVariables}}{{/hasPathVariables}}", {{#hasPathVariables}}{{#pathVariables}}{{name}}{{#hasMore}}, {{/hasMore}}{{/pathVariables}}{{/hasPathVariables}});
        
        try {
            List<{{entityName}}> {{entityVarName}}s = {{entityVarName}}RepositoryPort.{{repositoryMethod}}({{#hasPathVariables}}{{#pathVariables}}{{name}}{{#hasMore}}, {{/hasMore}}{{/pathVariables}}{{/hasPathVariables}});
            logger.info("Retrieved {} {{entityVarName}}s successfully", {{entityVarName}}s.size());
            return {{responseType}}.builder().build();
        } catch (Exception e) {
            logger.error("Error in {{operationId}}", e{{#hasPathVariables}}, {{#pathVariables}}{{name}}{{#hasMore}}, {{/hasMore}}{{/pathVariables}}{{/hasPathVariables}});
            throw e;
        }
    }

{{/complexOperations}}
{{/hasComplexOperations}}
}