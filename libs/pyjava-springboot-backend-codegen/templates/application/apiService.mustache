package {{packageName}};

import {{domain_ports_input}}.{{operationName}}UseCase;
import {{domain_ports_output}}.{{entityName}}RepositoryPort;
{{#requestType}}{{^requestIsJavaType}}import {{application_dto}}.{{serviceName}}.{{requestType}};{{/requestIsJavaType}}{{/requestType}}
{{#returnType}}{{^responseIsJavaType}}import {{application_dto}}.{{serviceName}}.{{returnType}};{{/responseIsJavaType}}{{/returnType}}
import {{domain_model}}.{{entityName}};
import {{application_mapper}}.{{entityName}}Mapper;
import {{infra_config_exceptions}}.NotFoundException;
import {{infra_config_exceptions}}.ConflictException;
import {{utils}}.LoggingUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;{{#operationName}}
{{#isListOperation}}
import java.util.List;
import java.math.BigDecimal;{{/isListOperation}}
{{/operationName}}

/**
 * Application service implementing {{operationName}} use case.
 * <p>
 * This service contains the business logic for {{operationName}} operation,
 * orchestrating domain objects and repository interactions. It serves as
 * the application layer in Clean Architecture, implementing use case interfaces
 * defined in the domain layer.
 * </p>
 * 
 * @author {{author}}
 * @version {{version}}
 */
@Service
@RequiredArgsConstructor
@Transactional
public class {{classname}} implements {{operationName}}UseCase {

    private static final LoggingUtils logger = LoggingUtils.getLogger({{classname}}.class);
    
    private final {{entityName}}RepositoryPort {{entityVarName}}RepositoryPort;
    private final {{entityName}}Mapper {{entityVarName}}Mapper;

    {{#isUpdate}}
    @Override
    public {{returnType}} execute(String {{entityVarName}}Id, {{requestType}} request) {
        logger.info("Executing {{operationName}} with {{entityVarName}}Id: {} and request: {}", {{entityVarName}}Id, request);
        
        try {
            {{entityName}} existing{{entityName}} = {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            // Update existing entity with request data
            {{entityName}} updated{{entityName}} = {{entityVarName}}Mapper.fromUpdateRequest(request);
            updated{{entityName}}.set{{entityName}}Id({{entityVarName}}Id);
            updated{{entityName}}.setCreatedAt(existing{{entityName}}.getCreatedAt());
            updated{{entityName}}.setStatus(existing{{entityName}}.getStatus());
            
            {{entityName}} saved{{entityName}} = {{entityVarName}}RepositoryPort.save(updated{{entityName}});
            logger.info("{{entityName}} updated successfully with ID: {}", {{entityVarName}}Id);
            
            return ({{returnType}}) {{entityVarName}}Mapper.toDto(saved{{entityName}});
        } catch (NotFoundException e) {
            logger.error("{{entityName}} not found in {{operationName}}", e, {{entityVarName}}Id);
            throw e;
        } catch (ConflictException e) {
            logger.error("{{entityName}} conflict in {{operationName}}", e, {{entityVarName}}Id);
            throw e;
        } catch (Exception e) {
            logger.error("Error in {{operationName}}", e, {{entityVarName}}Id);
            throw e;
        }
    }
    {{/isUpdate}}
    {{^isUpdate}}
    @Override
    public {{returnType}} execute({{requestType}} request) {
        logger.info("Executing {{operationName}} with request: {}", request);
        
        try {
            {{#isCreate}}
            // Convert request to domain model using mapper
            {{entityName}} {{entityVarName}} = {{entityVarName}}Mapper.fromCreateRequest(request);
            
            // Check if entity already exists to prevent conflicts
            if ({{entityVarName}}.get{{entityName}}Id() != null && {{entityVarName}}RepositoryPort.existsById({{entityVarName}}.get{{entityName}}Id())) {
                throw new ConflictException("{{entityName}} with ID " + {{entityVarName}}.get{{entityName}}Id() + " already exists");
            }
            
            {{entityName}} saved{{entityName}} = {{entityVarName}}RepositoryPort.save({{entityVarName}});
            logger.info("{{entityName}} created successfully with ID: {}", saved{{entityName}}.get{{entityName}}Id());
            
            return ({{returnType}}) {{entityVarName}}Mapper.toDto(saved{{entityName}});
            {{/isCreate}}
            {{#isGet}}
            {{entityName}} {{entityVarName}} = {{entityVarName}}RepositoryPort.findById(request)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            logger.info("{{entityName}} retrieved successfully with ID: {}", request);
            return ({{returnType}}) {{entityVarName}}Mapper.toDto({{entityVarName}});
            {{/isGet}}
            {{#isDelete}}
            // Verify entity exists before deletion
            {{entityName}} {{entityVarName}} = {{entityVarName}}RepositoryPort.findById(request)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            {{entityVarName}}RepositoryPort.deleteById(request);
            logger.info("{{entityName}} deleted successfully with ID: {}", request);
            
            // Return a simple response object
            return ({{returnType}}) new Object();
            {{/isDelete}}
            {{^isCreate}}{{^isGet}}{{^isDelete}}
            // List operation
            List<{{entityName}}> {{entityVarName}}s = {{entityVarName}}RepositoryPort.findAll();
            
            logger.info("Retrieved {} {{entityVarName}}s successfully", {{entityVarName}}s.size());
            
            return ({{returnType}}) {{entityVarName}}Mapper.toListResponse({{entityVarName}}s);
            {{/isDelete}}{{/isGet}}{{/isCreate}}
        } catch (NotFoundException e) {
            logger.error("{{entityName}} not found in {{operationName}}", e, request);
            throw e;
        } catch (ConflictException e) {
            logger.error("{{entityName}} conflict in {{operationName}}", e, request);
            throw e;
        } catch (Exception e) {
            logger.error("Error in {{operationName}}", e, request);
            throw e;
        }
    }
    {{/isUpdate}}
}