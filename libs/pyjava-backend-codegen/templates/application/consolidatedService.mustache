package {{packageName}};

import {{domain_ports_input}}.{{entityName}}UseCase;
import {{domain_ports_output}}.{{entityName}}RepositoryPort;
{{#hasCreate}}import {{application_dto}}.{{serviceName}}.Create{{entityName}}RequestContent;{{/hasCreate}}
{{#hasCreate}}import {{application_dto}}.{{serviceName}}.Create{{entityName}}ResponseContent;{{/hasCreate}}
{{#hasGet}}import {{application_dto}}.{{serviceName}}.Get{{entityName}}ResponseContent;{{/hasGet}}
{{#hasUpdate}}import {{application_dto}}.{{serviceName}}.Update{{entityName}}RequestContent;{{/hasUpdate}}
{{#hasUpdate}}import {{application_dto}}.{{serviceName}}.Update{{entityName}}ResponseContent;{{/hasUpdate}}
{{#hasDelete}}import {{application_dto}}.{{serviceName}}.Delete{{entityName}}ResponseContent;{{/hasDelete}}
{{#hasList}}import {{application_dto}}.{{serviceName}}.List{{entityName}}sResponseContent;{{/hasList}}
{{#hasComplexOperations}}
{{#complexOperations}}
import {{application_dto}}.{{serviceName}}.{{responseType}};
{{/complexOperations}}
{{/hasComplexOperations}}
import {{domain_model}}.{{entityName}};
import {{application_mapper}}.{{entityName}}Mapper;
import {{infra_config_exceptions}}.NotFoundException;
import {{utils}}.LoggingUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
{{#hasList}}
import java.util.List;
{{/hasList}}

/**
 * Consolidated application service implementing all {{entityName}} use cases.
 * 
 * @author {{author}}
 * @version {{version}}
 */
@Service
@RequiredArgsConstructor
@Transactional
public class {{entityName}}Service implements {{entityName}}UseCase {

    private static final LoggingUtils logger = LoggingUtils.getLogger({{entityName}}Service.class);
    
    private final {{entityName}}RepositoryPort {{entityVarName}}RepositoryPort;
    private final {{entityName}}Mapper {{entityVarName}}Mapper;

{{#hasCreate}}
    @Override
    public Create{{entityName}}ResponseContent create(Create{{entityName}}RequestContent request) {
        logger.info("Executing Create{{entityName}} with request: {}", request);
        
        try {
            {{entityName}} {{entityVarName}} = {{entityVarName}}Mapper.fromCreateRequest(request);
            {{entityName}} saved{{entityName}} = {{entityVarName}}RepositoryPort.save({{entityVarName}});
            logger.info("{{entityName}} created successfully with ID: {}", saved{{entityName}}.get{{entityName}}Id());
            return {{entityVarName}}Mapper.toCreateResponse(saved{{entityName}});
        } catch (Exception e) {
            logger.error("Error in Create{{entityName}}", e, request);
            throw e;
        }
    }
{{/hasCreate}}

{{#hasGet}}
    @Override
    public Get{{entityName}}ResponseContent get(String {{entityVarName}}Id) {
        logger.info("Executing Get{{entityName}} with {{entityVarName}}Id: {}", {{entityVarName}}Id);
        
        try {
            {{entityName}} {{entityVarName}} = {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            logger.info("{{entityName}} retrieved successfully with ID: {}", {{entityVarName}}Id);
            return {{entityVarName}}Mapper.toGetResponse({{entityVarName}});
        } catch (NotFoundException e) {
            logger.error("{{entityName}} not found in Get{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        } catch (Exception e) {
            logger.error("Error in Get{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        }
    }
{{/hasGet}}

{{#hasUpdate}}
    @Override
    public Update{{entityName}}ResponseContent update(String {{entityVarName}}Id, Update{{entityName}}RequestContent request) {
        logger.info("Executing Update{{entityName}} with {{entityVarName}}Id: {} and request: {}", {{entityVarName}}Id, request);
        
        try {
            {{entityName}} existing{{entityName}} = {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            // Merge request data into existing entity
            {{entityVarName}}Mapper.updateEntityFromRequest(request, existing{{entityName}});
            existing{{entityName}}.setUpdatedAt(java.time.Instant.now().toString());
            
            {{entityName}} saved{{entityName}} = {{entityVarName}}RepositoryPort.save(existing{{entityName}});
            logger.info("{{entityName}} updated successfully with ID: {}", {{entityVarName}}Id);
            
            return {{entityVarName}}Mapper.toUpdateResponse(saved{{entityName}});
        } catch (NotFoundException e) {
            logger.error("{{entityName}} not found in Update{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        } catch (Exception e) {
            logger.error("Error in Update{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        }
    }
{{/hasUpdate}}

{{#hasDelete}}
    @Override
    public Delete{{entityName}}ResponseContent delete(String {{entityVarName}}Id) {
        logger.info("Executing Delete{{entityName}} with {{entityVarName}}Id: {}", {{entityVarName}}Id);
        
        try {
            {{entityName}} {{entityVarName}} = {{entityVarName}}RepositoryPort.findById({{entityVarName}}Id)
                .orElseThrow(() -> new NotFoundException("{{entityName}} not found"));
            
            {{entityVarName}}RepositoryPort.deleteById({{entityVarName}}Id);
            logger.info("{{entityName}} deleted successfully with ID: {}", {{entityVarName}}Id);
            
            return Delete{{entityName}}ResponseContent.builder()
                .deleted(true)
                .message("{{entityName}} deleted successfully")
                .build();
        } catch (NotFoundException e) {
            logger.error("{{entityName}} not found in Delete{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        } catch (Exception e) {
            logger.error("Error in Delete{{entityName}}", e, {{entityVarName}}Id);
            throw e;
        }
    }
{{/hasDelete}}

{{#hasList}}
    @Override
    public List{{entityName}}sResponseContent list(Integer page, Integer size, String search) {
        logger.info("Executing List{{entityName}}s with page: {}, size: {}, search: {}", page, size, search);
        
        try {
            List<{{entityName}}> {{entityVarName}}s;
            if (search != null && !search.trim().isEmpty()) {
                {{entityVarName}}s = {{entityVarName}}RepositoryPort.findBySearchTerm(search, page, size);
            } else {
                {{entityVarName}}s = {{entityVarName}}RepositoryPort.findAll();
            }
            logger.info("Retrieved {} {{entityVarName}}s successfully", {{entityVarName}}s.size());
            return {{entityVarName}}Mapper.toListResponse({{entityVarName}}s, page != null ? page : 1, size != null ? size : 20);
        } catch (Exception e) {
            logger.error("Error in List{{entityName}}s", e);
            throw e;
        }
    }
{{/hasList}}

{{#hasComplexOperations}}
{{#complexOperations}}
    @Override
    public {{responseType}} {{methodName}}() {
        logger.info("Executing {{operationId}}");
        
        try {
            // TODO: Implement {{operationId}} business logic
            logger.info("{{operationId}} executed successfully");
            throw new UnsupportedOperationException("{{operationId}} not yet implemented");
        } catch (Exception e) {
            logger.error("Error in {{operationId}}", e);
            throw e;
        }
    }

{{/complexOperations}}
{{/hasComplexOperations}}
}